# 65816 Support for LLVM-MOS

## Goal

Make the 65816 feel like a flat 16MB computer. Programmers write normal C, pointers just work, no `__near`/`__far` required.

## Guiding Principle

**Programmers think in flat memory, not banks.**

## SNES Note

The SNES (primary real-world target) has non-contiguous memory in LoROM mode: each 32KB of ROM occupies the *upper half* of a 64KB bank, with RAM and I/O in the lower half. The flat 24-bit model still works—pointers are valid, arithmetic works. The **linker script** handles section placement. This is a linker concern, not a compiler concern.

## Decisions

| Decision | Choice | Why |
|----------|--------|-----|
| A register | Dynamic 8/16-bit via SEP/REP | **Required.** Can't write a `char` in 16-bit mode—STA writes 2 bytes. |
| X/Y registers | Static 16-bit | Switching to 8-bit **zeroes the high byte** (destructive). ASM devs say 8-bit X/Y is edge case. |
| Pointer size | `sizeof(void*) == 3` (i24 preferred, i32 if LLVM requires) | 3 bytes is natural. May need i32 for array indexing (multiply-by-3 vs shift). Investigate. |
| Function calls | All JSL/RTL (far calls) | Correct by default. Linker/post-link can narrow to JSR. |
| B register | Don't model | Never accessible except via XBA. LLVM doesn't handle register swaps well. Expose XBA as `__builtin_bswap16`. |
| Address spaces | Available, not required | Pure C works without them. Experts can use `__near`/`__zp` for optimization. |

## Memory Model

All pointers are 24-bit. All memory accesses use long addressing. All calls use JSL/RTL.

**i24 vs i32:** Prefer i24 (`sizeof(void*) == 3`) unless LLVM forces i32. The concern is array indexing: `arr[i]` with 3-byte pointers = multiply-by-3, with 4-byte = shift. Need to investigate whether this matters in practice or if LLVM's multiply-by-3 codegen is acceptable.

**The cost:** Every load/store is 4 bytes. Every call pushes 3 bytes.

**The benefit:** It just works. No near/far bugs. One `memcpy`.

## Optimization Layers

| Layer | What | Automatic? |
|-------|------|------------|
| Base | Flat 24-bit, correct C | Yes |
| Linker relaxation | Narrow instruction encoding | Yes |
| Post-link recompile | Full re-optimization with known addresses | Yes |
| Address spaces | `__near`, `__zp` for experts | No |

Pure C never needs address spaces. The automatic layers recover most performance.

### Linker Relaxation

Linker narrows encoding when addresses prove safe:
- `LDA.l $7E1234` → `LDA.w $1234` (if same bank)
- `JSL func` → `JSR func` (if same bank)

**Limitations:** Linker relaxation can only narrow *instruction encoding*. It cannot:
- Change addressing *modes* (can't turn long load into `(dp),Y` indexed)
- Change pointer *storage* sizes
- Use addressing modes only available to near pointers

This is why we need post-link recompilation, not just linker relaxation.

### Post-Link Recompilation

Like PGO, but with addresses instead of profiles. Feed final addresses back to compiler:

```
clang -c foo.c -o foo.o                         # Phase 1: Conservative (all far)
ld.lld foo.o -o foo.elf --emit-map=sym.map      # Phase 2: Get addresses
clang -c foo.c -o foo.o -faddress-hints=sym.map # Phase 3: Recompile with hints
ld.lld foo.o -o foo.elf                         # Phase 4: Final link
```

**What this enables (beyond linker relaxation):**
- `(dp),Y` indexed addressing for arrays in direct page
- Different register allocation based on known distances
- Inline functions that are provably nearby
- Optimal addressing mode selection

**Like PGO:** Stop iterating when you're bored. One pass is usually enough.

**Symbol map format (TBD):**
```
# symbol    address   size  type
main        0x008000  0x120 code
my_array    0x7E0100  0x400 data
dp_var      0x000010  0x02  direct_page
```

**Integration point:** Probably MOSSubtarget parses map, MOSInstructionSelector queries `isInDirectPage()`, `isInSameBank()`.

**Why this matters:** Gives asiekierka and other "near pointer or GTFO" people what they want, without forcing annotations on everyone else.

## Implementation

### What Exists
- `FeatureW65816` subtarget
- 65816 instructions defined (JSL, RTL, BRL, MVN, MVP, etc.)
- Long addressing modes
- M/X mode TSFlags

### What's Needed
- A8/A16 register variants with SEP/REP tracking
- X16/Y16 (static 16-bit)
- D, DBR, PBR registers
- RL imaginary registers (24-bit pointers)
- i32 pointer data layout (`p:32:8`)
- `mos65816cc` calling convention (all JSL/RTL)
- Native i16 legalization when A is 16-bit

### Key Files

| File | Changes |
|------|---------|
| `MOSRegisterInfo.td` | A8/A16, X16, Y16, D, DBR, PBR, RL0-RL85 |
| `MOSInstrInfo.td` | SEP/REP, 16-bit patterns |
| `MOSLegalizerInfo.cpp` | Native i16, i32 pointers |
| `MOSInstructionSelector.cpp` | A width tracking |
| `MOSSubtarget.cpp` | p:32:8 data layout |
| `MOSFrameLowering.cpp` | 3-byte return addresses |
| `MOSCallLowering.cpp` | JSL/RTL for all calls |

## Phases

1. **Make it work**: All far addressing, all JSL/RTL, correct but slow
2. **Linker relaxation**: Narrow encoding when safe
3. **Post-link recompile**: Full optimization with address knowledge

## Open Questions

1. **ABI documentation**: Need to write it down
2. **SEP/REP batching**: How aggressively to batch same-width A operations?
3. **Soft stack location**: Can be anywhere (not just bank 0)?

## Address Spaces (Expert Opt-in)

For experts who want manual control:
- `__near` - 16-bit pointer, bank-relative addressing modes
- `__zp` / `__dp` - direct page pointer, `(dp),Y` addressing

These exist for micro-optimization. Pure C doesn't need them.

**Why they matter:** Some addressing modes are only available to near pointers. A near pointer to const data in the same section can use more efficient access patterns than a far pointer. This was the same argument for zero page address spaces on 6502—pointers in ZP have optimization opportunities that pointers outside ZP don't.

## Not Doing

- Modeling B register (XBA is an intrinsic instead)
- *Requiring* near/far pointer types (they exist, but aren't imposed)
- Mixed 8/16-bit X/Y modes (static 16-bit only)
- 6502/65816 ABI interop (clean break, different pointer sizes)

